The API guide
***************
Now let's see how to use the python API instead of the command line

.. code-block:: python
    
    from mutate_pdb import Mutagenesis, generate_mutations
    from pele_files import CreateLaunchFiles, create_20sbatch
    from analysis import SimulationData, analyse_all, box_plot, all_profiles, extract_all, find_top_mutations, consecutive_analysis
    
The mutate_pdb module
======================
``Mutagenesis`` is a simple class to perform saturated mutagenesis or single mutagenesis

.. code-block:: python
    
    run = Mutagenesis("test.pdb", "A:145", "pdb_files") #Arguments are PDB, Chain ID:position num and the name of a folder for the output
    pdbs = run.saturated_mutagenesis(hydrogens=True, mode=0)
    run.accelerated_insert() # The pmx package removes the last column of the PDB file so it needs to be reinserted

    run = Mutagenesis("test.pdb", "A:145", "pdb_files")
    new_aa = "CYS"
    file_ = run.single_mutagnesis(new_aa, hydrogens=True, mode=0) #we don't need the accelerated insert in this case, since it is a single mutation
    
``generate_mutations`` is function that uses the class to mutate at several positions at once, 20 X 20 mutations or consecutively mutate at several positions.

.. code-block:: python
    
    pdbs = generate_mutations("test.pdb", "A:145", hydrogens=True, multiple=False, folder="pdb_files", consec=False)

| The *multiple* argument is used when we want to perform 20 X 20 mutations
| The *consec* argument is used when you select 1 of the mutations of the first round of mutagenesis to start a second round, it will preserve the name of the PDB.

The pele_files module
=======================
```CreateLaunchFiles`` is a class that can generate the .yaml and the .sh files for the PELE simulations for a single PDB system.

.. code-block:: python

    run = CreateLaunchFiles(input_="test.pdb", ligchain="L", ligname="ligand", atom1="C:1:CU", 
    atom2="L:1:N1", cpus=24, test=False, initial=None, cu=False, seed=12345, nord=False)
    
    run.input_creation("yaml_name")
    run.slurm_creation("slurm_name")
    
``create_20sbatch`` is a function that uses the class to create the pele files for more than 1 PDBs, it acceps directories, files or iterables, for instance the list of pdbs generated by generate_mutations

.. code-block:: python

    pdbs = generate_mutations("test.pdb", "A:145", hydrogens=True, multiple=False, folder="pdb_files", consec=False)
    slurm_files = create_20sbatch(ligchain="L", ligname="ligand", atom1="C:1:CU", atom2="L:1:N1", file_= pdbs, cpus=24, test=False, initial=None,
                    cu=False, seed=12345, nord=False)

The Analysis
================
| The main script combines the 2 functions from before and automatically submits the created slurm files as jobs to the HPCs in marenostrum or in Nord.
| But the returned simulations must be analyzed to see if any of the mutations has improved the binding energy, the distance of both of the metrics in relation to the wild type, which is where the Analysis modules comes into play.

``SimulationData`` is a class that stores data of the simulation, it contains the binding energies and the distance in angstroms of the ligand and the protein

.. code-block:: python

    data = SimulationData(folder="PELE_simulation", points=30, pdb=10) # points are how many data points to consider for binding energies and the distance analysis, and pdb is how many best trajectories to extract 
    data.filtering() #Takes the previous arguments and performs the filtering process to keep the top 30 data points
    data.set_distance(original_distance)
    data.set_binding(original_binding_energy)
    
``analyse_all`` is the function that uses the class to store the simulation data from the 20 simulations (19 for the mutations + 1 for the wildtype) and returns a dictionary

.. code-block:: python

    data_dict = analyse_all(folders=".", box=30, traj=10)
    
``box_plot`` takes as the argument the *data_dict* to generate a box plot of all the distance and binding energy variations of the 19 mutations

.. code-block:: python

    box_plot(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", dpi=800) # the position_num is an argument used to give name to the different plots, the default is the residue anem and position
    
``all_profiles`` is a function that creates scatter plots, the same as those created after the PELE simulations but the mutations are superimposed with the wildtype. Again it takes as argument *data_dict*

.. code-block:: python

     all_profiles(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", dpi=800)

``extract_all`` is a function that extracts, of all the simulation steps from a mutation, the top 10 steps in terms of ligand-protein binding distance. The function takes as argument data_dict to extract from all the mutations.

.. code-block:: python

    extract_all(res_dir="analysis_dir", data_dict=data_dict, folders=".", cpus=24) # the folders if the same argument for the folder sin analyse_all
    
``find_top_mutations`` is a function that searches within the data_dict to find those mutations that improves on a chosen metric (energy, distance or both) with an increment superior to a predetermined threshold, as a results it creates a report with all the plots generated for those mutations in a PDF file.

.. code-block:: python

    find_top_mutations(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", output="summary", analysis="distance", thres=-0.1)

``consecutive_analysis`` is the function that gathers all of the previous functions and allows the analysis of more than 1 position.

.. code-block:: python

    consecutive_analysis(file_name=["path1", "path2", "path3"], dpi=800, box=30, traj=10, output="summary", plot_dir=None, opt="distance", cpus=24, thres=-0.1) # file_name argument can accept an iterable, directory or a file that contains the path to the folders where the different pele simulations are stored.
    
