The API guide
***************
Now let's see how to use the python API instead of the command line

.. code-block:: python
    
    from satumut import CreateSlurmFiles
    from satumut.mutate_pdb import Mutagenesis, generate_mutations
    from satumut.pele_files import CreateYamlFiles, create_20sbatch
    from satumut.simulation import SimulationRunner, saturated_simulation, plurizyme_simulation
    from satumut.analysis import SimulationData, analyse_all, box_plot, all_profiles, extract_all, find_top_mutations, consecutive_analysis
    from satumut.rs_analysis import SimulationRS, analyse_rs, box_plot_rs, create_report, consecutive_analysis_rs

    
The main script
================
``CreateSlurmFiles`` is s class from the satumut main script which creates the slurm file necessary to launch a job in marenostrum, automatically if set.

.. code-block:: python
    
    run = CreateSlurmFiles(input_="test.pdb", ligchain="L", ligname="ligand", atoms=["C:1:CU","L:1:N1"],
    position=["A:154"], dir_=None, hydrogen=True, multiple=False, cpus=25, pdb_dir="pdb_files", test=False, consec=False, cu=False, seed=12345, nord=False, stesp=700,
    dpi=800, box=30, traj=10, output="summary", plot_dir=None, opt="distance", thres=-0.1, single_mutagenesis=None, plurizyme_at_and_res=None, radius=5.0, fixed_resids=[], 
    factor=None, analysis=False)
    
    slurm = run.slurm_creation() # creates the slurm file


The mutate_pdb module
======================
``Mutagenesis`` is a simple class to perform saturated mutagenesis or single mutagenesis

.. code-block:: python
    
    run = Mutagenesis("test.pdb", "A:145", "pdb_files") #Arguments are PDB, Chain ID:position num and the name of a folder for the output
    pdbs = run.saturated_mutagenesis(hydrogens=True)
    run.accelerated_insert() # The pmx package removes the last column of the PDB file so it needs to be reinserted

    run = Mutagenesis("test.pdb", "A:145", "pdb_files")
    new_aa = "CYS"
    file_ = run.single_mutagnesis(new_aa, hydrogens=True) #we don't need the accelerated insert in this case, since it is a single mutation
    
``generate_mutations`` is function that uses the class to mutate at several positions at once given a list of positions.  



.. code-block:: python
    
    pdbs = generate_mutations("test.pdb", "A:145", hydrogens=True, multiple=False, folder="pdb_files", consec=False, single=None)

| The *multiple* argument is used when we want to perform 20 X 20 mutations
| The *consec* argument is used when you select 1 of the mutations of the first round of mutagenesis to start a second round, it will preserve the name of the PDB.
| if *sinlge=None* the function will mutate the positions to all the other 19 residues and when *single=LYS* it will perform single mutagenesis to the user specified residue.
In single mutagenesis you can specify also the protonated state for example LYN or O instead of LYS or K if you want the lysine to be unprotonated.

The pele_files module
=======================
``CreateYamlFiles`` is a class that can generate the .yaml files for the PELE simulations given an input PDB.

.. code-block:: python

    run = CreateYamlFiles(input_="test.pdb", ligchain="L", ligname="ligand", atoms=["C:1:CU","L:1:N1"],
    cpus=25, test=False, initial=None, cu=False, seed=12345, nord=False, stesp=700, factor=None, analysis=False)
    
    run.input_creation("yaml_name")

    
``create_20sbatch`` is a function that uses the class to create the pele files for more than 1 PDBs, it acceps directories, files or iterables, for instance the list of pdbs generated by generate_mutations

.. code-block:: python

    pdbs = generate_mutations("test.pdb", ["A:145"], hydrogens=True, multiple=False, folder="pdb_files", consec=False)
    yaml_files = create_20sbatch(ligchain="L", ligname="ligand", atoms=["C:1:CU", "L:1:N1"], file_= pdbs, cpus=25, test=False, initial=None,
                    cu=False, seed=12345, nord=False, stesp=700, factor=None, analysis=False)
                    
The simulation module
======================
``SimulationRunner`` is a class that controls and calls the pele platform to run the simulations

.. code-block:: python

    simulation = SimulationRunner(input_="test.pdb", cpus=25, dir_="test_results")
    simulation.side_function() # Creates and changes the working directory so all the simulation results are kept in the same folder
    simulation.submit(yaml_files) # Given a list of yaml_files it creates a subprocess running a simulation for each of the files
    
``saturated_simulation`` is a function that combines the different functions from the 3 modules to perform saturated mutagenesis of the given positions and analyse the results from the simulations

.. code-block:: python

    saturated_simulation(input_="test.pdb", position=["A:145"], ligchain="L", ligname="ligand", atoms=["C:1:CU","L:1:N1"], cpus=25, dir_=None, hydrogen=True,
                         multiple=False, pdb_dir="pdb_files", consec=False, test=False, cu=False, seed=12345, nord=False, steps=700, dpi=800, box=30, traj=10, output="summary", plot_dir=None, opt="distance", thres=-0.1, factor=None, simulation=False)

``plurizyme_simulation`` is a function that uses the different functions from the 3 previouys modules to perform single mutagenesis on various positions found around a user specified atom, the *plurizyme_at_and_res* argument,

.. code-block:: python

    plurizyme_simulation(input_="test.pdb", ligchain="L", ligname="ligand", atoms=["C:1:CU","L:1:N1"], single_mutagenesis="SER", plurizyme_at_and_res="A:132:CA", 
                        radius=5.0, fixed_resids=[], cpus=25, dir_=None, hydrogen=True, pdb_dir="pdb_files", consec=False, test=False, cu=False, seed=12345, 
                        nord=False, steps=800, factor=None)

The Analysis module
====================
| The main script combines the 2 functions from before and automatically submits the created slurm files as jobs to the HPCs in marenostrum or in Nord.
| But the returned simulations must be analyzed to see if any of the mutations has improved the binding energy, the distance of both of the metrics in relation to the wild type, which is where the Analysis modules comes into play.

``SimulationData`` is a class that stores data of the simulation, it contains the binding energies and the distance in angstroms of the ligand and the protein

.. code-block:: python

    data = SimulationData(folder="PELE_simulation", traj=10, cata_dist=3.5) # points are how many data points to consider for binding energies and the distance analysis, and pdb is how many best trajectories to extract  
    data.filtering() #Takes the previous arguments and performs the filtering process to keep the top 30 data points
    data.set_distance(original_distance)
    data.set_binding(original_binding_energy)
    
``analyse_all`` is the function that uses the class to store the simulation data from the 20 simulations (19 for the mutations + 1 for the wildtype) and returns a dictionary

.. code-block:: python

    data_dict = analyse_all(folder="PELE_simulation", wild="original", res_dir="mutant_results", box=30, traj=10)
    
``box_plot`` takes as the argument the *data_dict* to generate a box plot of all the distance and binding energy variations of the 19 mutations

.. code-block:: python

    box_plot(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", dpi=800) # the position_num is an argument used to give name to the different plots, the default is the residue anem and position
    
``all_profiles`` is a function that creates scatter plots, the same as those created after the PELE simulations but the mutations are superimposed with the wildtype. Again it takes as argument *data_dict*

.. code-block:: python

     all_profiles(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", dpi=800)

``extract_all`` is a function that extracts, of all the simulation steps from a mutation, the top 10 steps in terms of ligand-protein binding distance. The function takes as argument *data_dict* to extract from all the mutations.

.. code-block:: python

    extract_all(res_dir="analysis_dir", data_dict=data_dict, folders=".", cpus=25) # the folders if the same argument for the folder sin analyse_all
    
``find_top_mutations`` is a function that searches within the data_dict to find those mutations that improves on a chosen metric (energy, distance or both) with an increment superior to a predetermined threshold, as a results it creates a report with all the plots generated for those mutations in a PDF file.

.. code-block:: python

    find_top_mutations(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", output="summary", analysis="distance", thres=-0.1)

``consecutive_analysis`` is the function that gathers all of the previous functions and allows the analysis of more than 1 position.

.. code-block:: python

    consecutive_analysis(file_name=["path1", "path2", "path3"], dpi=800, box=30, traj=10, output="summary", plot_dir=None, opt="distance", cpus=25, thres=-0.1) # file_name argument can accept an iterable, directory or a file that contains the path to the folders where the different pele simulations are stored.
    
The rs_analysis module
========================
| The rs analysis module is used to analyse thoses simulations where it is posible to determine the enantiomeric product from the susbtrates using the dihedral angles.
| The functions are very similar of those in the Analysis module but used to distinguish the enantiomers.


``SimulationRS`` is a class that stores data of the simulation, it contains the binding energies, the distance in angstroms of protein-ligand pairs and the enantiomeric information.

.. code-block:: python

    data = SimulationRS(folder="PELE_simulation", dihedral_atoms=["A:X:X", "A:X:X", "A:X:X", "A:X:X"], input_pdb="input.pdb", res_dir="mutant_RS", pdb=10) # points are how many data points to consider for binding energies and the distance analysis, and pdb is how many best trajectories to extract 
    data.filtering() #Takes the previous arguments and performs the filtering process to keep the top 30 data points
    data.set_distance(original_distance)
    data.set_binding(original_binding_energy)

``analyse_rs`` is the function that uses the class to store the simulation data from the 20 simulations (19 for the mutations + 1 for the wildtype) and returns a dictionary

.. code-block:: python

    data_dict = analyse_rs(folder="PELE_simulation",wild="original", initial_pdb="input.pdb", res_dir="mutant_RS", improve="R", cpus=10, traj=10, position_num="T234")

``all_profiles`` is a function that creates scatter plots, the same as those created after the PELE simulations but the mutations are superimposed with the wildtype. Again it takes as arguments *data_dict* and *mode*

.. code-block:: python

     all_profiles(res_dir="analysis_dir", data_dict=data_dict, position_num="T165", dpi=800, mode="RS")

``box_plot_rs`` takes as the argument the *data_dict* to generate a box plot of all the distance and binding energy variations of the 19 mutations

.. code-block:: python

    box_plot_rs(res_dir="analysis_RS", data_dict=data_dict, position_num="T165", dpi=800) # the position_num is an argument used to give name to the different plots, the default is the residue anem and position     
     
``extract_all`` is a function that extracts, of all the simulation steps from a mutation, the top 10 steps in terms of ligand-protein binding distance. The function takes as arguments *data_dict* and *function* to extract from all the mutations and determine the enantiomer it produces.

.. code-block:: python

    extract_all(res_dir="analysis_dir", data_dict=data_dict, folders="PELE_fimulations", cpus=25, function="extract_10_pdb_single_rs") # the folders if the same argument for the folder sin analyse_all
